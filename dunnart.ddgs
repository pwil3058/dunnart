// dunnart specification for dunnart grammar specification language

%{
import std.string;

import ddlib.components;
import symbols; // This is only because we're bootstrapping
import grammar; // This is only because we're bootstrapping

string preamble;

SymbolTable symbolTable;

alias string Tag;
alias Tag[] TagList;
alias SymbolId[] SymbolIdList;
alias Production[] ProductionList;

struct ApPair {
    Associativity assoc;
    Precedence prec;
}

this {
    symbolTable = new SymbolTable;
    grammar = new GrammarSpecification(symbolTable);
}
%}

%field  Symbol symbol
%field  SymbolId symbolId
%field  SymbolIdList symbolIdList
%field  TagList tagList
%field  ApPair apPair
%field  Production production
%field  ProductionList productionList;

%token  REGEX           (\(\S+\))
%token  LITERAL         ("\S+")
%token  TOKEN           "%token"
%token  FIELD           "%field"
%token  LEFT            "%left"
%token  RIGHT           "%right"
%token  NONASSOC        "%nonassoc"
%token  PRECEDENCE      "%prec"
%token  SKIP            "%skip"
%token  ERROR           "%error"
%token  LEXERROR        "%lexerror"
%token  NEWSECTION      "%%"
%token  COLON           ":"
%token  DOT             "."
%token  IDENT           ([a-zA-Z]+[a-zA-Z0-9_]*)
%token  FIELDNAME       (<[a-zA-Z]+[a-zA-Z0-9_]*>)
%token  ACTION          (!\{(.|[\n\r])*?!\})
%token  DCODE           (%\{(.|[\n\r])*?%\})

%skip (/\*(.|[\n\r])*?\*/)
%skip (//[^\n\r]*)
%skip (\s+)

%%
specification: preamble definitions "%%" production_rules.

allowable_ident: IDENT ?( symbolTable.is_allowable_name($1.ddMatchString) ?)
    | allowable_ident
        !{
            auto msg = format("%s: illegal name", $1.ddMatchString);
            abort(msg, symbolTable.get_declaration_point($1.ddMatchString));
        !}
    .

preamble: !{ \\ do nothing !}
    | DCODE !{ preamble = $1.ddMatchString[2 .. $ - 2]. !}
    .

definitions : definition
    | definitions definition
    .

definition: token_definition
    | precedence_definition
    | field_definition
    | skip_definition
    .

token_definition: "%token" new_token_name pattern
        !{
            $$.symbol = symbolTable.new_token($2.ddMatchString, $3.ddMatchString, $2.ddLocation);
        !} 
    | "%token" FIELDNAME new_token_name pattern
        !{
            $$.symbol = symbolTable.new_token($3.ddMatchString, $4.ddMatchString, $3.ddLocation, $2.ddMatchString[1 .. $ - 1]);
        !}
    .

new_token_name: allowable_ident ?( symbolTable.is_known_symbol($1.ddMatchString) ?)
        !{
            abort("already declared.", symbolTable.get_declaration_point($1.ddMatchString));
        !}
    | allowable_ident
    .

pattern: REGEX
    | LITERAL
    .

precedent_definition: "%left" tag_list
        !{
            symbolTable.set_precedences(Associativity.left, $2.tagList, $1.ddLocation);
        !}
    | "%right" tag_list
        !{
            symbolTable.set_precedences(Associativity.right, $2.tagList, $1.ddLocation);
        !}
    | "%nonassoc" tag_list
        !{
            symbolTable.set_precedences(Associativity.nonassoc, $2.tagList, $1.ddLocation);
        !}
    .

tag_list: allowable_ident ?( symbolTable.is_known_tag($1.ddMatchString) ?)
        !{
            abort("already declared.", symbolTable.get_declaration_point($1.ddMatchString));
        !}
    | allowable_ident !{ $$.tagList = new Tag[$1.ddMatchString] !}
    | tag_list allowable_ident !{ $1.tagList ~= $1.ddMatchString !}
    .

field_definition: "$field" fieldType fieldName
        !{
            if ($3.ddMatchString in fieldDefinitions) {
                auto previous = fieldDefinitions[$3.ddMatchString].declaredAt;
                abort("already declared.", previous);
            }
            fieldDefinitions[$3.ddMatchString] = new FieldDefinition($3.ddMatchString, $2.ddMatchString);
        !}
    | "$field" fieldType fieldName fieldConversionFunction
        !{
            if ($3.ddMatchString in fieldDefinitions) {
                auto previous = fieldDefinitions[$3.ddMatchString].declaredAt;
                abort("already declared.", previous);
            }
            fieldDefinitions[$3.ddMatchString] = new FieldDefinition($3.ddMatchString, $2.ddMatchString, $4.ddMatchString);
        !}
    .

fieldType: allowable_ident.

fieldName: allowable_ident ?( symbolTable.is_known_field($1.ddMatchString) ?)
        !{
            abort("already declared.", symbolTable.get_declaration_point($1.ddMatchString));
        !}
    | allowable_ident
    .

fieldConversionFunction: allowable_ident.

skip_definition: "$skip" REGEX !{ symbolTable.add_skip_rule($1.ddMatchString); !}.

production_rules: production_list
    | production_rules production_list
    .

production_list: production_list_head right_hand_side_list "."
        !{
            foreach (production; $2.productionList) {
                production.leftHandSide = $1.symbol.id;
                grammar.add_production(production);
            }
        !}
    .

production_list_head: allowable_ident ":" ?( symbolTable.is_known_token($1.ddMatchString) ?)
        !{
            auto lineNo = symbolTable.get_declaration_point($1.ddMatchString).lineNumber;
            auto msg = format("%s: token (defined at line %s) cannot be used as left hand side", $1.ddMatchString, lineNo);
            abort(msg, $1.ddLocation);
        !}
    | allowable_ident ":" ?( symbolTable.is_known_tag($1.ddMatchString) ?)
        !{
            auto lineNo = symbolTable.get_declaration_point($1.ddMatchString).lineNumber;
            auto msg = format("%s: tag (defined at line %s) cannot be used as left hand side", $1.ddMatchString, lineNo);
            abort(msg, $1.ddLocation);
        !}
    | allowable_ident ":" ?( symbolTable.is_defined($1.ddMatchString) ?)
        !{
            auto lineNo = symbolTable.get_declaration_point($1.ddMatchString).lineNumber;
            auto msg = format("%s: already defined at line %s", $1.ddMatchString, lineNo);
            abort(msg, $1.ddLocation);
        !}
    | allowable_ident ":"
        !{
            $$.symbol = symbolTable.define_non_terminal($1.ddMatchString, $1.ddLocation);
        !}
    .

right_hand_sides_list: right_hand_side !{ $$.productionList = new Production[$1.production]; !}
    | right_hand_sides_list "|" right_hand_side !{ $$.productionList = [$1].productionList ~ [$3.production]; !}
    .

right_hand_side: ACTION
        !{
            $$.production = Production(0, 0, new SymbolId[], Associativity.nonassoc, 0, "", $1.ddMatchString);
        !}
    | symbol_list ACTION
        !{
            $$.production = Production(0, 0, $1.symbolIdList, Associativity.nonassoc, 0, "", $2.ddMatchString);
        !}
    | symbol_list PREDICATE ACTION
        !{
            $$.production = Production(0, 0, $1.symbolIdList, Associativity.nonassoc, 0, $2.ddMatchString, $3.ddMatchString);
        !}
    | symbol_list PREDICATE
        !{
            $$.production = Production(0, 0, $1.symbolIdList, Associativity.nonassoc, 0, $2.ddMatchString, "");
        !}
    | symbol_list tagged_precedence ACTION
        !{
            $$.production = Production(0, 0, $1.symbolIdList, $2.assoc, $2.prec, "", $3.ddMatchString);
        !}
    | symbol_list PREDICATE tagged_precedence ACTION
        !{
            $$.production = Production(0, 0, $1.symbolIdList, $3.assoc, $3.prec, $2.ddMatchString, $4.ddMatchString);
        !}
    | symbol_list PREDICATE tagged_precedence
        !{
            $$.production = Production(0, 0, $1.symbolIdList, $3.assoc, $3.prec, $2.ddMatchString, "");
        !}
    .

tagged_precedence: PRECEDENCE IDENT
        !{
            if (symbolTable.is_known_tag($2.ddMatchSring)) {
                auto tag = get_symbol($2.ddMatchSring, $2.ddLocation);
                $$.apPair = ApPair(tag.associativity, tag.precedence);
            } else if (symbolTable.is_known_token($2.ddMatchSring)) {
                // This doesn't count as a reference for tokens
                auto token = get_symbol($2.ddMatchSring);
                $$.apPair = ApPair(tag.associativity, tag.precedence);
            } else {
                auto msg = format("%s: unknown precedence tag", $2.ddMatchString);
                abort(msg, $2.ddLocation);
            }
        !}
    .

symbol_list: symbol !{ $$.symbolIdList = new SymbolId[$1.symbolId]; !}
    | symbol_list symbol !{ $$.symbolIdList = $1.symbolIdList ~ $2.symbolId; !}
    .

symbol: allowable_ident
        !{
            auto symbol = symbolTable.get_symbol($1.ddMatchText, $1.ddLocation, true);
            $$.symbolId = symbol.id;
        !}
    | LITERAL
        !{
            auto symbol = symbolTable.get_literal_token($1.ddMatchText, $1.ddLocation);
            if (symbol is null) {
                auto msg = format("%s: unknown literal token", $1.ddMatchString);
                abort(msg, $1.ddLocation);
            }
            $$.symbolId = symbol.id;
        !}
    | "%error" !{ $$.symbolId = SpecialSymbols.parseError; !}
    | "%lexerror" !{ $$.symbolId = SpecialSymbols.lexError; !}
    .
