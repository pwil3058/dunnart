// dunnart specification for dunnart grammar specification language

%{
import std.string;

import ddlib.components;
import symbols; // This is only because we're bootstrapping

string preamble;

SymbolTable symbolTable;

alias string[] TagList;
%}

%field  Symbol symbol
%field  TagList tagList;

%token  REGEX           (\(\S+\))
%token  LITERAL         ("\S+")
%token  TOKEN           "%token"
%token  FIELD           "%field"
%token  LEFT            "%left"
%token  RIGHT           "%right"
%token  NONASSOC        "%nonassoc"
%token  PRECEDENCE      "%prec"
%token  SKIP            "%skip"
%token  ERROR           "%error"
%token  LEXERROR        "%lexerror"
%token  NEWSECTION      "%%"
%token  IDENT           ([a-zA-Z]+[a-zA-Z0-9_]*)
%token  FIELDNAME       (<[a-zA-Z]+[a-zA-Z0-9_]*>)
%token  ACTION          (!\{(.|[\n\r])*?!\})
%token  DCODE           (%\{(.|[\n\r])*?%\})

%skip (/\*(.|[\n\r])*?\*/)
%skip (//[^\n\r]*)
%skip (\s+)

%%
specification: preamble definitions "%%" production_rules.

allowable_ident: IDENT ?( symbolTable.is_allowable_name($1.ddMatchString) ?)
    | allowable_ident
        !{
            auto msg = format("%s: illegal name", $1.ddMatchString);
            abort(msg, symbolTable.get_declaration_point($1.ddMatchString));
        !}
    .

preamble: !{ \\ do nothing !}
    | DCODE !{ preamble = $1.ddMatchString[2 .. $ - 2]. !}
    .

definitions : definition
    | definitions definition
    .

definition: token_definition
    | precedence_definition
    | field_definition
    | skip_definition
    .

token_definition: "%token" new_token_name pattern
        !{
            $$.symbol = symbolTable.new_token($2.ddMatchString, $3.ddMatchString, $2.ddLocation);
        !} 
    | "%token" FIELDNAME new_token_name pattern
        !{
            $$.symbol = symbolTable.new_token($3.ddMatchString, $4.ddMatchString, $3.ddLocation, $2.ddMatchString[1 .. $ - 1]);
        !}
    .

new_token_name: allowable_ident ?( symbolTable.is_known_symbol($1.ddMatchString) ?)
        !{
            abort("already declared.", symbolTable.get_declaration_point($1.ddMatchString));
        !}
    | allowable_ident
    .

pattern: REGEX | LITERAL.

precedent_definition: "%left" tag_list
        !{
            symbolTable.set_precedences(Associativity.left, $2.tagList, $1.ddLocation);
        !}
    | "%right" tag_list
        !{
            symbolTable.set_precedences(Associativity.right, $2.tagList, $1.ddLocation);
        !}
    | "%nonassoc" tag_list
        !{
            symbolTable.set_precedences(Associativity.nonassoc, $2.tagList, $1.ddLocation);
        !}
    .

tag_list: allowable_ident ?( symbolTable.is_known_tag($1.ddMatchString) ?)
        !{
            abort("already declared.", symbolTable.get_declaration_point($1.ddMatchString));
        !}
    | allowable_ident !{ $$.tagList = new [$1.ddMatchString] !}
    | tag_list allowable_ident !{ $1.tagList ~= $1.ddMatchString !}
    .

field_definition: "$field" fieldType fieldName
        !{
            if ($3.ddMatchString in fieldDefinitions) {
                auto previous = fieldDefinitions[$3.ddMatchString].declaredAt;
                abort("already declared.", previous);
            }
            fieldDefinitions[$3.ddMatchString] = new FieldDefinition($3.ddMatchString, $2.ddMatchString);
        !}
    | "$field" fieldType fieldName fieldConversionFunction
        !{
            if ($3.ddMatchString in fieldDefinitions) {
                auto previous = fieldDefinitions[$3.ddMatchString].declaredAt;
                abort("already declared.", previous);
            }
            fieldDefinitions[$3.ddMatchString] = new FieldDefinition($3.ddMatchString, $2.ddMatchString, $4.ddMatchString);
        !}
    .

fieldType: allowable_ident.

fieldName: allowable_ident ?( symbolTable.is_known_field($1.ddMatchString) ?)
        !{
            abort("already declared.", symbolTable.get_declaration_point($1.ddMatchString));
        !}
    | allowable_ident
    .

fieldConversionFunction: allowable_ident.

skip_definition: "$skip" REGEX !{ symbolTable.add_skip_rule($1.ddMatchString); !}.

production_rules: production_list
    | production_rules production_list
    .

production_list: production_list_head right_hand_side_list ".".

production_list_head: allowable_ident ":" ?( symbolTable.is_known_token($1.ddMatchString) ?)
        !{
            auto lineNo = symbolTable.get_declaration_point($1.ddMatchString).lineNumber;
            auto msg = format("%s: token (defined at line %s) cannot be used as left hand side", $1.ddMatchString, lineNo);
            abort(msg, $1.ddLocation);
        !}
    | allowable_ident ":" ?( symbolTable.is_known_tag($1.ddMatchString) ?)
        !{
            auto lineNo = symbolTable.get_declaration_point($1.ddMatchString).lineNumber;
            auto msg = format("%s: tag (defined at line %s) cannot be used as left hand side", $1.ddMatchString, lineNo);
            abort(msg, $1.ddLocation);
        !}
    | allowable_ident ":" ?( symbolTable.is_defined($1.ddMatchString) ?)
        !{
            auto lineNo = symbolTable.get_declaration_point($1.ddMatchString).lineNumber;
            auto msg = format("%s: already defined at line %s", $1.ddMatchString, lineNo);
            abort(msg, $1.ddLocation);
        !}
    | allowable_ident ":"
        !{
            $$.symbol = symbolTable.define_non_terminal($1.ddMatchString, $1.ddLocation);
        !}
    .

right_hand_sides_list: right_hand_side !{ $$.rhsList = new [$1.rhs]; !}
    | right_hand_sides_list "|" right_hand_side !{ $$.rhsList = [$1].rhsList ~ [$3.rhs]; !}
    .

right_hand_side: ACTION
    | symbol_list ACTION
    | symbol_list PREDICATE ACTION
    | symbol_list PREDICATE
    | symbol_list PRECEDENCE ACTION
    | symbol_list PREDICATE PRECEDENCE ACTION
    | symbol_list PREDICATE PRECEDENCE
    .

symbol_list: symbol
    | symbol_list symbol
    .

symbol: allowable_ident | LITERAL | "%error" .

left_hand_side: allowable_ident.
